# =============================================
# ATHENA - Automated Tool for Hardware EvaluatioN.
# Copyright © 2009 - 2014 CERG at George Mason University <cryptography.gmu.edu>.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see http://www.gnu.org/licenses
# or write to the Free Software Foundation,Inc., 51 Franklin Street,
# Fifth Floor, Boston, MA 02110-1301  USA.
# =============================================

#! ./perl

#####################################################################
# APPLICATION: exhaustive_search
# Version: 0.1
# - General Implementation under the assumption that the user has entered everything correctly.
# - No "idiot checks"
#
# Version: 0.2
# - Cross check options library for consistency
# - Error checks
# 
# This app will perform an exhaustive search with different combination of options
# 2 levels of options are provided.
# once all the level 1 options are run, we will extract 'X' best results
# The rest of the options are generated by combining the level 2 options 
# with the best options from level 1
#####################################################################
#################################################################################################################################################
# number of runs (worst case) = (no of freqs requested) x [(no of level 1 combinations) + ((BEST_LEVEL_1_OPTION_SETS) x (no of level 2 combinations))]
##################################################################################################################################################

use Cwd;

my (%LEVEL_1_OPTIONS, %LEVEL_2_OPTIONS, @TARGET_CLK_FREQS, $RUN_ALL_OPTIONS, $BEST_LEVEL_1_OPTION_SETS);
my (%LEVEL_1_COMBINATIONS);
my (%LEVEL_1_RUN_TRACKING, %LEVEL_1_RESULT_TRACKING);
my (@BEST_LEVEL_1_COMBINATIONS);
my (%LEVEL_1_2_COMBINATIONS);
my (@SYNTHESIS_TOOLS, @IMPLEMENTATION_TOOLS, @ALLTOOLS);
my (%GENERICS);

#####################################################################
# application function
#####################################################################
sub application{
	printOut("\nRunning application : EXHAUSTIVE SEARCH\n");
	printLocalProgress("Application : EXHAUSTIVE SEARCH\n");
	my ($VENDOR, $FAMILY, $DEVICE);
	
	$VENDOR = uc($DEV_OBJ->getVendor());
	$FAMILY = uc($DEV_OBJ->getFamily());
	$DEVICE = uc($DEV_OBJ->getDevice());
	
	#read config
	&readExhaustiveConfig($VENDOR, $FAMILY);
	
	#=== Get Clock Net name
	my $ClkNet = &get_ClkName();
	
	#=====form level 1 combinations
	&Level1Combinations();
	#&printLevel1Hash();

	#=====dispatch level 1
	my @COMBINATIONS = (keys %LEVEL_1_COMBINATIONS); 
	@COMBINATIONS = sort { $a <=> $b } @COMBINATIONS;
	
	my $noofCombinations = $#COMBINATIONS+1;
	printOut("NUMBER of combinations at level 1: $noofCombinations\n");
	
	printOut("No of frequencies: ". ($#TARGET_CLK_FREQS + 1) ."\n");
	
	my $RUNNO = 1;
	
	foreach my $FREQ_STR (@TARGET_CLK_FREQS){
		@FREQ = split(/,/,$FREQ_STR);
		printOut("\n\n ITERATING THROUGH THE FOLLOWING FREQUENCY:\t$FREQ_STR\n");
		$REQ_SYN_FREQ = $FREQ[0];
		$REQ_IMP_FREQ = $FREQ[1];
		$REQ_SYN_FREQ = "" if($REQ_SYN_FREQ =~ m/[a-zA-Z]+/gi);
		$REQ_IMP_FREQ = "" if($REQ_IMP_FREQ =~ m/[a-zA-Z]+/gi);
		
		printOut("default synthesis frequency\n") if($REQ_SYN_FREQ =~ m/[a-zA-Z]+/gi);
		printOut("default implementation frequency\n") if($REQ_IMP_FREQ =~ m/[a-zA-Z]+/gi);
		
		#Array for the list of dispatched directories
		my @DIRECTORY_LIST = ();
		
		#clear the variables
		%LEVEL_1_RUN_TRACKING = ();
		%LEVEL_1_RESULT_TRACKING = ();
		@BEST_LEVEL_1_COMBINATIONS = ();
		%LEVEL_1_2_COMBINATIONS = ();

		foreach my $COMBINATION (@COMBINATIONS){
			#keep track of runno + combination
			$LEVEL_1_COMBO_RUNNO_TRACKING{"run_".($RUNNO)} = $COMBINATION;
			
			#printOut("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~begin dispatch loop ONE 1\n\n\n");
			
			#clone to get a new device with same information
			my $NEWDEV_OBJ = dclone($DEV_OBJ);
			
			printOut("RUNNO:\t$RUNNO\tCOMBINATION:\t$COMBINATION\n");
			$NEWDEV_OBJ->setRunNo($RUNNO);
			$RUNNO++;
			
			#modify the options
			my %COMBO_HASH = %{$LEVEL_1_COMBINATIONS{$COMBINATION}};
			&modify_options(\$NEWDEV_OBJ, \%COMBO_HASH);
			
			#set the new device parameters
			$NEWDEV_OBJ->setDispatchType($DISPATCH_TYPE_NONE);
			$NEWDEV_OBJ->setLocalApplication("single_run");
			$NEWDEV_OBJ->setRequestedFreqs($REQ_SYN_FREQ, $REQ_IMP_FREQ);
			
			#dispatch device
			my $deviceDir = dispatchDevice(\$NEWDEV_OBJ);
			push(@DIRECTORY_LIST,$deviceDir);
			
			#printOut("\n\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~end dispatch loop ONE 1\n");
		}
		
		#=====run level 1 dispatches PER REQ FREQ
		#EXECUTE the scripts
		printOut("\nExecuting dispatched scripts...\n");
		my %RunHash = (
			vendor => "$VENDOR",
			title => "Exhaustive search - level 1",
			directories => \@DIRECTORY_LIST,
			requested_frequency => $REQ_IMP_FREQ,
			run_all_options => $RUN_ALL_OPTIONS,
			max_runs => $maxSimultaneousRuns,
		);
		&ExecuteScripts(\%RunHash);
		
		#=====extract level 1 results
		foreach my $DIRECTORY (@DIRECTORY_LIST){
			#my $PATH = getcwd;
			my @RESULTS = extract_perf_results($VENDOR, "", "", $DIRECTORY, $ClkNet);
			
			my @split = split(/[\/]+/,$DIRECTORY);
			my $RunNo = $split[$#split];

			#keep track of results... might come in handy for extensions
			#push(@{$LEVEL_1_RESULT_TRACKING{$DIRECTORY}},@RESULTS};
			$LEVEL_1_RESULT_TRACKING{$RunNo} = \@RESULTS;
		}
		
		#printHash{\%LEVEL_1_RESULT_TRACKING};
		
		#=====find the best results
		#check BEST_LEVEL_1_OPTION_SETS
		@SORTED_DIRLIST = sort{ @{$LEVEL_1_RESULT_TRACKING{$b}}[0] <=> @{$LEVEL_1_RESULT_TRACKING{$a}}[0]} (keys %LEVEL_1_RESULT_TRACKING);
		printOut("Runs Sorted according to achieved frequency: \n".join("\n",@SORTED_DIRLIST)."\n\n");
		for($i=0;$i<$BEST_LEVEL_1_OPTION_SETS;$i++){
			my $COMBINATION = $LEVEL_1_COMBO_RUNNO_TRACKING{$SORTED_DIRLIST[$i]};
			printOut("COMBINATION:\t$COMBINATION\n");
			my %COMBO_HASH = %{$LEVEL_1_COMBINATIONS{$COMBINATION}};
			push(@BEST_LEVEL_1_COMBINATIONS, \%COMBO_HASH);
		}
		
		foreach my $COMBO_REF (@BEST_LEVEL_1_COMBINATIONS){
			my %COMBO_HASH = %{$COMBO_REF};
			printOut("\n");
			foreach my $TOOL (@ALLTOOLS){
				my %TOOL_HASH = %{$COMBO_HASH{$TOOL}};
				my @OPTLIST = (keys %TOOL_HASH);
				foreach $OPT (@OPTLIST){
					my $FLAG = $TOOL_HASH{$OPT};
					printOut("\t\tTOOL: $TOOL\tOPTION: $OPT\tFLAG: $FLAG\n");
				}
			}
		}
		
		#=====combine best level 1 and level 2 options, form level (1,2) combinations
		&Level12Combinations();
		
		#=====dispatch level 1,2
		
		my @COMBINATIONS = (keys %LEVEL_1_2_COMBINATIONS);
		@COMBINATIONS = sort { $a <=> $b } @COMBINATIONS;
		my $noofCombinations = $#COMBINATIONS+1;
		printOut("NUMBER of combinations at level 2: $noofCombinations\n");
		
		my @DIRECTORY_LIST = ();
		
		foreach my $COMBINATION (@COMBINATIONS){
			#printOut("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~begin dispatch loop TWO 2\n\n\n");
			
			#clone to get a new device with same information
			my $NEWDEV_OBJ = dclone($DEV_OBJ);
			
			printOut("RUNNO:\t$RUNNO\tCOMBINATION:\t$COMBINATION\n");
			$NEWDEV_OBJ->setRunNo($RUNNO);
			$RUNNO++;
			
			#modify the options
			my %COMBO_HASH = %{$LEVEL_1_2_COMBINATIONS{$COMBINATION}};
			&modify_options(\$NEWDEV_OBJ, \%COMBO_HASH);
			
			#set the new device parameters
			$NEWDEV_OBJ->setDispatchType($DISPATCH_TYPE_NONE);
			$NEWDEV_OBJ->setLocalApplication("single_run");
			$NEWDEV_OBJ->setRequestedFreqs($REQ_SYN_FREQ, $REQ_IMP_FREQ);
			
			#dispatch device
			my $deviceDir = dispatchDevice(\$NEWDEV_OBJ);
			push(@DIRECTORY_LIST,$deviceDir);
			
			#printOut("\n\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~end dispatch loop TWO 2\n");
		}
		
		#EXECUTE the scripts
		printOut("\nExecuting dispatched scripts...\n");
		my %RunHash = (
			vendor => "$VENDOR",
			title => "Exhaustive search - level 2",
			directories => \@DIRECTORY_LIST,
			requested_frequency => $REQ_IMP_FREQ,
			run_all_options => $RUN_ALL_OPTIONS,
			max_runs => $maxSimultaneousRuns,
		);
		&ExecuteScripts(\%RunHash);
	}
	
}

#####################################################################
# Read the config file
# NOTE: publish the exhaustive config file format
#####################################################################
sub readExhaustiveConfig{
	my ($VENDOR, $FAMILY) = @_;
	
	if(lc($VENDOR) eq "xilinx"){
		@SYNTHESIS_TOOLS = @XILINX_SYNTHESIS_TOOLS;
		@IMPLEMENTATION_TOOLS = @XILINX_IMPLEMENTATION_TOOLS;
	}
	elsif(lc($VENDOR) eq "altera"){
		@SYNTHESIS_TOOLS = @ALTERA_SYNTHESIS_TOOLS;
		@IMPLEMENTATION_TOOLS = @ALTERA_IMPLEMENTATION_TOOLS;
	}
	elsif(lc($VENDOR) eq "actel"){
		@SYNTHESIS_TOOLS = @ACTEL_SYNTHESIS_TOOLS;
		@IMPLEMENTATION_TOOLS = @ACTEL_IMPLEMENTATION_TOOLS;
	}
	#check loadLevelOpts function, loading happens there
	#@ALLTOOLS = (@SYNTHESIS_TOOLS, @IMPLEMENTATION_TOOLS);
	
	#open file and load data
	
	my $CONFIG_FILE = "$CONFIG_DIR/exhaustive_search.txt";
	@ConfigData = @{getProcessedText($CONFIG_FILE , "exhaustive_search")};
	my $DATA = join("\n", @ConfigData);
	if($DATA =~ m/EXHAUSTIVE_SEARCH_STRATEGY\s*=\s*${REGEX_CONFIG_ITEM_IDENTIFIER}/gi){
		$EXHAUSTIVE_SEARCH_STRATEGY  = $1;		
	}
	my $CONFIG_OPTION_FILE = "$CONFIG_DIR/exhaustive.$EXHAUSTIVE_SEARCH_STRATEGY.txt";
	printOut("CONFIG_OPTION_FILE		$CONFIG_OPTION_FILE\n");
	@ConfigData = @{getProcessedText($CONFIG_OPTION_FILE , "exhaustive_search_option")};
	my $DATA = join("\n", @ConfigData);

	if($DATA =~ m/TARGET_CLK_FREQ\s*=\s*([(), \d\w.]+)/gi){
		my $TARGET_CLK_FREQ = $1;
		my @freqData = split(/[() ,]+/,$TARGET_CLK_FREQ);
		my $size = $#freqData;
		for($i=1;$i<$size;$i++){
			push(@TARGET_CLK_FREQS, "$freqData[$i],$freqData[$i+1]");
			$i++;
		}
		printOut("Target clock frequencies ".join("-",@TARGET_CLK_FREQS)."\n");
	}
	if($DATA =~ m/RUN_ALL_OPTIONS\s*=\s*([\w]+)/gi){
		$RUN_ALL_OPTIONS = lc($1);
		printOut("RUN_ALL_OPTIONS			$RUN_ALL_OPTIONS\n");
	}
	if($DATA =~ m/BEST_LEVEL_1_OPTION_SETS\s*=\s*([\w]+)/gi){
		$BEST_LEVEL_1_OPTION_SETS = lc($1);
		printOut("BEST_LEVEL_1_OPTION_SETS	$BEST_LEVEL_1_OPTION_SETS\n");
	}
	
	
	my ($NoOfL1Combinations, $NoOfL2Combinations);
	($NoOfL1Combinations, $LEVEL_1_OPTIONS_REF) = loadLevelOpts($VENDOR, $FAMILY, 1, @ConfigData);
	($NoOfL2Combinations,  $LEVEL_2_OPTIONS_REF) = loadLevelOpts($VENDOR, $FAMILY, 2, @ConfigData);
	
	%LEVEL_1_OPTIONS = %{$LEVEL_1_OPTIONS_REF};
	%LEVEL_2_OPTIONS = %{$LEVEL_2_OPTIONS_REF};
	
	#number of runs (worst case) = (no of freqs requested) x [(no of level 1 combinations) + ((BEST_LEVEL_1_OPTION_SETS) x (no of level 2 combinations))]
	my $NoOfRuns = ($#TARGET_CLK_FREQS+1) * ($NoOfL1Combinations + ($BEST_LEVEL_1_OPTION_SETS * $NoOfL2Combinations));
	
	printOut("==================================================\n");
	printOut("Number of Requested Frequencies : ". ($#TARGET_CLK_FREQS+1) ."\n");
	printOut("Number of combinations at level 1 : $NoOfL1Combinations\n");
	printOut("Number of combinations at level 2 : $NoOfL2Combinations\n");
	printOut("Number of BEST_LEVEL_1_OPTION_SETS : $BEST_LEVEL_1_OPTION_SETS\n");
	
	printOut("\nTOTAL NUMBER OF RUNS : ".($#TARGET_CLK_FREQS+1)." * ($NoOfL1Combinations + ($BEST_LEVEL_1_OPTION_SETS * $NoOfL2Combinations))\n");
	printOut("TOTAL NUMBER OF RUNS : $NoOfRuns\n");
	printOut("==================================================\n");
	
	printLocalProgress("Number of Requested Frequencies : ". ($#TARGET_CLK_FREQS+1) ."\n");
	printLocalProgress("Number of combinations at level 1 : $NoOfL1Combinations\n");
	printLocalProgress("Number of combinations at level 2 : $NoOfL2Combinations\n");
	printLocalProgress("Number of level 1 option sets : $BEST_LEVEL_1_OPTION_SETS\n");
	printLocalProgress("TOTAL NUMBER OF RUNS : ".($#TARGET_CLK_FREQS+1)." * ($NoOfL1Combinations + ($BEST_LEVEL_1_OPTION_SETS * $NoOfL2Combinations)) = $NoOfRuns\n\n");
}

#####################################################################
# Loads the level options
#####################################################################
sub loadLevelOpts{
	my ($VENDOR, $FAMILY, $LEVEL, @optdata) = @_;
	my %LEVEL_HASH = ();
	my $NoOfCombinations = 1;

	my $size = $#optdata;
	#printOut("Size of the array at level $level - $size\n");
	
	my $i = 0;
	for($i=0;$i<$size;$i++){
	
		#skip all the # signs in the options
		my $substring = substr $optdata[$i], 0, 1;
		next if($substring =~ /#/);
		
		my $LEVEL_START_STR = "LEVEL_".$LEVEL."_OPTIONS_BEGIN";
		my $LEVEL_END_STR = "LEVEL_".$LEVEL."_OPTIONS_END";
		
		my $VENDOR_START_STR = $VENDOR."_OPTIONS_BEGIN";
		my $VENDOR_END_STR = $VENDOR."_OPTIONS_END";
		
		if($optdata[$i] =~ m/${VENDOR_START_STR}/gi){
			my $VendorDone = 0; #0 = false, 1=true
			while ($VendorDone == 0){
				$i++;
				my $substring = substr $optdata[$i], 0, 1;
				if($optdata[$i] =~ m/${VENDOR_END_STR}/gi){
					$VendorDone = 1;
				}
				elsif($substring =~ /[\s\\\\-_\/#]+/){}
				else{
					if($optdata[$i] =~ m/${LEVEL_START_STR}/gi){
						my $LevelDone = 0;
						while ($LevelDone == 0){
							$i++;
							my $substring = substr $optdata[$i], 0, 1;
							if($optdata[$i] =~ m/${LEVEL_END_STR}/gi){
								$LevelDone = 1;
							}
							elsif($substring =~ /[\s\\\\-_\/#]+/){}
							else{
								#============== READ options for the level,vendor ==============#
								my $TOOL = $VENDOR."_SYNTHESIS_TOOL";
								if($optdata[$i] =~ m/${TOOL}\s*=\s*${REGEX_CONFIG_ITEM_IDENTIFIER}/gi){
									my $SYNTHESIS_TOOL = $1;
									printOut("SYNTHESIS_TOOL				 $SYNTHESIS_TOOL\n");
									$LEVEL_HASH{$TOOL} = $SYNTHESIS_TOOL;
									
									#remove the other synthesis tools from @ALLTOOLS
									@ALLTOOLS = ($SYNTHESIS_TOOL, @IMPLEMENTATION_TOOLS);
								}
								
								foreach my $T (@ALLTOOLS){
									my $TOOL = $T;
									$TOOL = uc($TOOL);
									my %TOOL_HASH = ();
									my $TOOL_STR = $VENDOR."_".$TOOL."_OPT";
									if($optdata[$i] =~ m/${TOOL_STR}\s*=/gi){
										my $toolDone = 0;
										while ($toolDone == 0){
											$i++;
											my $substring = substr $optdata[$i], 0, 1;
											if(($optdata[$i] =~ /END[\s^\w]*OPT/i)){
												$toolDone = 1;
											}
											elsif($substring =~ /[\s\\\\-_\/#]+/){}
											else{
												my ($OPTION, @FLAGS, @OPTS1, @OPTS2);
												
												#ignore - symbols
												$optdata[$i] =~ s/^[-]+//;

												@OPTS1 = split(/[\s-=]+/,$optdata[$i]);
												$OPTION = shift @OPTS1;
												@OPTS2 = split(/[\s,]+/,join("",@OPTS1));

												@FLAGS = @OPTS2;
												#printOut("TOOL: $TOOL		OPTION: $OPTION		FLAGS: ".join("-",@FLAGS)."\n");
												
												#you can check for specific options here.
												#EX: costtable values
												
												#============ HANDLE VIRTEX5, SPARTAN6 and VIRTEX6
												#printOut("\nLOGKEY 324234 : $TOOL\n");
												$TOOL = "MAP" if((lc($TOOL) eq "par") and (lc($FAMILY) eq "virtex5") and ($LEVEL == 2));
												#printOut("LOGKEY 324234 : LEVEL = $LEVEL \t TOOL = $TOOL \t FAMILY = $FAMILY \n");
												#printOut("LOGKEY 324234 : $TOOL\n");
												
												if(lc($OPTION) eq "xilinx_cost_table_values"){
													$OPTION = "t";
													my @CTV = parse_CostTableVals(join("",@OPTS2));
													@FLAGS = (@CTV);
													#printOut join("-",@FLAGS)."\n");
												}
												elsif(lc($OPTION) eq "altera_seed_values"){
													$OPTION = "SEED";
													my @CTV = parse_CostTableVals(join("",@OPTS2));
													@FLAGS = (@CTV);
													#printOut join("-",@FLAGS)."\n");
												}												
												else{
													#($$OPTION, @FLAGS) = translateOptions($VENDOR, $FAMILY, $TOOL, $OPTION, @GUI_FLAGS);
												}
												
												#keep track of no of options
												$NoOfCombinations *= ($#FLAGS+1);
												
												# Case conversion for flags
												if(lc($VENDOR) eq "xilinx"){
													$OPTION = lc($OPTION);
													@FLAGS = map(lc($_),@FLAGS);
												}
												elsif(lc($VENDOR) eq "altera"){
													$OPTION = uc($OPTION);
													@FLAGS = map(uc($_),@FLAGS);
												}
												elsif(lc($VENDOR) eq "actel"){
													print "EXHAUSTIVE - VENDOR not supported";
												}
												
												#Push the flags
												$LEVEL_HASH{$TOOL}{$OPTION} = \@FLAGS;
											}
										}
									}
								}
							}
						}
					}
					#vendor not found
				}
			}
		}
	}
	return $NoOfCombinations, \%LEVEL_HASH;
}

#####################################################################
# parces CosttableValues
#####################################################################
sub parse_CostTableVals{
	my $data = $_[0];
		
	my @mainlist = split(/[\s;,]+/,$data);
	foreach $item (@mainlist){
		my @sublist = split(/[\s:]+/,$item);
		if($#sublist < 2){
			push(@RETURN_VALS, $item);
		}
		next if($#sublist != 2);
		next if($sublist[0] < $sublist[0]);
		my $start = $sublist[0];
		my $step = $sublist[1];
		my $end = $sublist[2];
		while($start <= $end){
			push(@RETURN_VALS, $start);
			$start += $step;
		}
	}
	@RETURN_VALS = sort{$a <=> $b} @RETURN_VALS;
	
	return @RETURN_VALS;
}


#####################################################################
# Creates the combinations of level 1 options
#####################################################################
sub Level1Combinations{
	#my %LEVEL_1_COMBINATIONS = ();
	
	foreach my $TOOL (@ALLTOOLS){
		my %TOOL_HASH = %{$LEVEL_1_OPTIONS{$TOOL}};
		my @OPTLIST = (keys %TOOL_HASH);
		foreach $OPT (@OPTLIST){
			my @FLAGS = @{$TOOL_HASH{$OPT}};
			next if($#FLAGS < 0);
			#printOut("\n\nTOOL: $TOOL\tOPTION: $OPT\tFLAGS: ".join(",",@FLAGS)."\n") if($#FLAGS > 0);
			
			my @COMBINATIONS = (keys %LEVEL_1_COMBINATIONS);
			@COMBINATIONS = sort { $a <=> $b } @COMBINATIONS;
			my $noofCombinations = $#COMBINATIONS+1;
			#printOut("NUMBER of combinations: $noofCombinations\n");
			
			if($noofCombinations <= 0){
				#printOut("FIRST COMBINATION====================================\n\n");
				my $COUNT = 1;
				foreach $FLAG (@FLAGS){
					$LEVEL_1_COMBINATIONS{$COUNT}{$TOOL}{$OPT} = $FLAG;
					$COUNT++;
				}
			}
			else{
				foreach my $COM (@COMBINATIONS){
					my $COUNT = $COM;
					my %COMBO_HASH = %{$LEVEL_1_COMBINATIONS{$COM}};
					foreach my $FLAG (@FLAGS){
						if($COUNT != $COM){
							#make a copy of hash==============================================
							
							#this doesnt seem to work, since its a reference
							#$LEVEL_1_COMBINATIONS{$COUNT} = \%COMBO_HASH;
							
							#the interative way
							my @TOOLLIST = (keys %COMBO_HASH);
							foreach my $TOOL1 (@TOOLLIST){
								my %TOOL_HASH = %{$COMBO_HASH{$TOOL1}};
								my @OPTLIST = (keys %TOOL_HASH);
								foreach $OPT1 (@OPTLIST){
									my $FLAG1 = $TOOL_HASH{$OPT1};
									#printOut("TOOL1: $TOOL1\tOPTION: $OPT1\tFLAG: $FLAG1\n");
									$LEVEL_1_COMBINATIONS{$COUNT}{$TOOL1}{$OPT1} = $FLAG1;
								}
							}
							#make a copy of hash==============================================
						}
						$LEVEL_1_COMBINATIONS{$COUNT}{$TOOL}{$OPT} = $FLAG;
						$COUNT += $noofCombinations;
					}
				}
			}
			#printhash(%LEVEL_1_COMBINATIONS);
		}
	}
}

#####################################################################
# Creates the combinations of level ()1,2) options
#####################################################################
sub Level12Combinations{
	#my %LEVEL_1_2_COMBINATIONS = ();
	
	#FIRST we need to copy teh best combinations to level2 combinations....
	#printOut("SUB======================================= LEVEL12COMBINATIONS\n");
	my $COUNT = 0;
	foreach my $COMBO_REF (@BEST_LEVEL_1_COMBINATIONS){
		my %COMBO_HASH = %{$COMBO_REF};
		$COUNT++;
		foreach my $TOOL (@ALLTOOLS){
			my %TOOL_HASH = %{$COMBO_HASH{$TOOL}};
			my @OPTLIST = (keys %TOOL_HASH);
			foreach $OPT (@OPTLIST){
				my $FLAG = $TOOL_HASH{$OPT};
				$LEVEL_1_2_COMBINATIONS{$COUNT}{$TOOL}{$OPT} = $FLAG;
				#printOut("COMBINATION: $COUNT\t\tTOOL: $TOOL\tOPTION: $OPT\tFLAG: $FLAG\n");
			}
		}
	}
	#printLevel12Hash();
	
	#now we need to iterate through the level2options and add them to the hash....
	foreach my $TOOL (@ALLTOOLS){
		my %TOOL_HASH = %{$LEVEL_2_OPTIONS{$TOOL}};
		my @OPTLIST = (keys %TOOL_HASH);
		foreach $OPT (@OPTLIST){
			my @FLAGS = @{$TOOL_HASH{$OPT}};
			next if($#FLAGS < 0);
			#printOut("\n\nTOOL: $TOOL\tOPTION: $OPT\tFLAGS: ".join(",",@FLAGS)."\n") if($#FLAGS > 0);
			
			my @COMBINATIONS = (keys %LEVEL_1_2_COMBINATIONS);
			@COMBINATIONS = sort { $a <=> $b } @COMBINATIONS;
			my $noofCombinations = $#COMBINATIONS+1;
			printOut("NUMBER of combinations: $noofCombinations\n");
			
			if($noofCombinations <= 0){
				#printOut("FIRST COMBINATION====================================\n\n");
				my $COUNT = 1;
				foreach $FLAG (@FLAGS){
					$LEVEL_1_2_COMBINATIONS{$COUNT}{$TOOL}{$OPT} = $FLAG;
					$COUNT++;
				}
			}
			else{
				foreach my $COM (@COMBINATIONS){
					my $COUNT = $COM;
					my %COMBO_HASH = %{$LEVEL_1_2_COMBINATIONS{$COM}};
					foreach my $FLAG (@FLAGS){
						if($COUNT != $COM){
							#make a copy of hash==============================================
							
							#this doesnt seem to work, since its a reference
							#$LEVEL_1_2_COMBINATIONS{$COUNT} = \%COMBO_HASH;
							
							#the interative way
							my @TOOLLIST = (keys %COMBO_HASH);
							foreach my $TOOL1 (@TOOLLIST){
								my %TOOL_HASH = %{$COMBO_HASH{$TOOL1}};
								my @OPTLIST = (keys %TOOL_HASH);
								foreach $OPT1 (@OPTLIST){
									my $FLAG1 = $TOOL_HASH{$OPT1};
									#printOut("TOOL1: $TOOL1\tOPTION: $OPT1\tFLAG: $FLAG1\n");
									$LEVEL_1_2_COMBINATIONS{$COUNT}{$TOOL1}{$OPT1} = $FLAG1;
								}
							}
							#make a copy of hash==============================================
						}
						$LEVEL_1_2_COMBINATIONS{$COUNT}{$TOOL}{$OPT} = $FLAG;
						$COUNT += $noofCombinations;
					}
				}
			}
			printLevel12Hash();
		}
	}
}


#####################################################################
# Print info about level 1 hash
#####################################################################
sub printLevel1Hash{
	printOut("\nLEVEL 1 Hash===================================================\n");
	print "\nLEVEL 1 Hash===================================================\n";
	my @COMBINATIONS = (keys %LEVEL_1_COMBINATIONS);
	@COMBINATIONS = sort { $a <=> $b } @COMBINATIONS;
	my $noofCombinations = $#COMBINATIONS+1;
	printOut("NUMBER of combinations: $noofCombinations\n");
	   print "NUMBER of combinations: $noofCombinations\n";
	foreach my $i (@COMBINATIONS){
		my %COMBO_HASH = %{$LEVEL_1_COMBINATIONS{$i}};
		printOut("\n");
		   print "\n";
		foreach my $TOOL (@ALLTOOLS){
			my %TOOL_HASH = %{$COMBO_HASH{$TOOL}};
			my @OPTLIST = (keys %TOOL_HASH);
			foreach $OPT (@OPTLIST){
				my $FLAG = $TOOL_HASH{$OPT};
				printOut("COMBINATION: $i\t\tTOOL: $TOOL\tOPTION: $OPT\tFLAG: $FLAG\n");
				   print "COMBINATION: $i\t\tTOOL: $TOOL\tOPTION: $OPT\tFLAG: $FLAG\n";
			}
		}
	}
	printOut("\n===================================================\n");
	print "\n===================================================\n";
}

#####################################################################
# Print info about level 1 hash
#####################################################################
sub printLevel12Hash{
	printOut("\nLEVEL 2 Hash===================================================\n");
	my @COMBINATIONS = (keys %LEVEL_1_2_COMBINATIONS);
	@COMBINATIONS = sort { $a <=> $b } @COMBINATIONS;
	my $noofCombinations = $#COMBINATIONS+1;
	printOut("NUMBER of combinations: $noofCombinations\n");
	foreach my $i (@COMBINATIONS){
		my %COMBO_HASH = %{$LEVEL_1_2_COMBINATIONS{$i}};
		printOut("\n");
		foreach my $TOOL (@ALLTOOLS){
			my %TOOL_HASH = %{$COMBO_HASH{$TOOL}};
			my @OPTLIST = (keys %TOOL_HASH);
			foreach $OPT (@OPTLIST){
				my $FLAG = $TOOL_HASH{$OPT};
				printOut("COMBINATION: $i\t\tTOOL: $TOOL\tOPTION: $OPT\tFLAG: $FLAG\n");
			}
		}
	}
	printOut("\n===================================================\n");
}

#####################################################################
# Modifies the options
#####################################################################
sub modify_options{
	my ($DEV_REF, $HASH_REF) = @_;
	my $DEVICE = $$DEV_REF;
	my %COMBO_HASH = %{$HASH_REF};
	my $VENDOR = $DEVICE->getVendor();
	
	#print("\nmodify_options ======================================BEGIN \n");
	#$DEVICE->printOpts();
	foreach my $TOOL (@ALLTOOLS){
		my %TOOL_HASH = %{$COMBO_HASH{$TOOL}};
		my @OPTLIST = (keys %TOOL_HASH);
		foreach $OPT (@OPTLIST){
			my $FLAG = $TOOL_HASH{$OPT};
			#printOut("COMBINATION: $i\t\tTOOL: $TOOL\tOPTION: $OPT\tFLAG: $FLAG\n");
			#if($DEVICE->checkOpt($VENDOR, $TOOL, $OPT, $FLAG) eq "true"){
				#printOut("Flag already present\n");
				#$DEVICE->deleteToolOpt($VENDOR, $TOOL, $OPT);
			#}
			$DEVICE->deleteToolOpt($VENDOR, $TOOL, $OPT);
			$DEVICE->addOpt($VENDOR, $TOOL, $OPT, $FLAG);
		}
	}
	#$DEVICE->printOpts();
	#print("modify_options ======================================END \n\n");
}













1;